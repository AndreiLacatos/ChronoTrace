using System.Diagnostics;
using ChronoTrace.ProfilingInternals.DataExport;

namespace ChronoTrace.ProfilingInternals;

/// <summary>
/// Manages the lifecycle of method profiling, acting as the central orchestration point for capturing trace data.
/// </summary>
/// <remarks>
/// <para>
///   IMPORTANT: INTERNAL LIBRARY USE ONLY.
/// </para>
/// <para>
///   This class is marked <c>public</c> solely to enable its use by code generated by the
///   <c>ChronoTrace</c> library. It is not intended for direct invocation or manipulation
///   by consumer application code.
/// </para>
/// <para>
///   Interacting with this class directly from application code will lead to incorrect profiling data,
///   concurrency issues, application instability, or other undefined behavior.
///   The <c>ChronoTrace</c> library manages the lifecycle and usage of this context internally.
/// </para>
/// </remarks>
public sealed class ProfilingContext
{
    private readonly SemaphoreSlim _semaphore;
    private readonly List<ProfiledMethodInvocation> _methodCalls;
    private readonly ITraceVisitor _visitor;
    private ushort _invocationCounter;
    private ushort _pendingCalls;

    internal ProfilingContext(ITraceVisitor visitor)
    {
        _visitor = visitor;
        _invocationCounter = 0;
        _pendingCalls = 0;
        _methodCalls = new List<ProfiledMethodInvocation>(capacity: 100);
        _semaphore = new SemaphoreSlim(1, 1);
    }

    /// <summary>
    /// Signals the beginning of a profiled method's execution.
    /// This method is called by generated instrumentation code.
    /// </summary>
    /// <param name="methodName">The name of the method being profiled.</param>
    /// <returns>A unique invocation ID for this specific method call instance.</returns>
    public ushort BeginMethodProfiling(string methodName)
    {
        _semaphore.Wait();
        ++_pendingCalls;
        var invocationId = ++_invocationCounter;
        var pendingCall = new ProfiledMethodInvocation
        {
            Id = invocationId,
            MethodName = methodName,
        };

        _methodCalls.Add(pendingCall);
        _semaphore.Release();

        return invocationId;
    }

    /// <summary>
    /// Signals the end of a profiled method's execution.
    /// This method is called by generated instrumentation code.
    /// </summary>
    /// <param name="invocationId">The unique ID returned by <see cref="BeginMethodProfiling"/>
    /// for this method call instance.</param>
    /// <remarks>
    /// This operation is thread-safe. It records the completion timestamp for the specified invocation.
    /// If an invalid <paramref name="invocationId"/> is provided, the call is ignored.
    /// It's crucial that <paramref name="invocationId"/> corresponds to an active profiling session
    /// started by <see cref="BeginMethodProfiling"/>.
    /// </remarks>
    public void EndMethodProfiling(ushort invocationId)
    {
        var currentTicks = Stopwatch.GetTimestamp();
        _semaphore.Wait();
        if (invocationId == 0 || invocationId > _invocationCounter)
        {
            // invalid invocationId
            _semaphore.Release();
            return;
        }

        --_pendingCalls;
        _methodCalls[invocationId - 1].ReturnTick = currentTicks;
        _semaphore.Release();
    }

    /// <summary>
    /// Triggers the processing of all completed method invocations using the configured <see cref="ITraceVisitor"/>.
    /// This method is called by generated instrumentation code.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If there are still methods that have begun profiling but not yet ended (i.e. pending calls exist),
    /// this method will return without processing traces to avoid data loss.
    /// </para>
    /// </remarks>
    public void CollectTraces()
    {
        _semaphore.Wait();
        var hasPendingCalls = _pendingCalls > 0;
        _semaphore.Release();
        if (hasPendingCalls)
        {
            // the current profiling scope is not finished yet, there are profiled methods in execution
            return;
        }

        _visitor.BeginVisit();
        for (var i = 0; i < _invocationCounter; i++)
        {
            _visitor.VisitTrace(TraceAdapter.Adapt(_methodCalls[i]));
        }
        _visitor.Complete();
        
        // reset state
        _invocationCounter = 0;
        _methodCalls.Clear();
    }
}
